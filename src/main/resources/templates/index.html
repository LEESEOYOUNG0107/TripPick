<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8"/>
    <title>TripPick AI</title>
    <link rel="stylesheet" th:href="@{/index.css}">
</head>
<body>
<header class="app-header" id="appHeader">
    <div class="logo">
        <span class="mark"></span>
        <span>TripPick</span>
    </div>
    <nav class="nav-actions">
        <a href="/" class="btn ghost" id="btnHome">홈</a>
        <a href="/favorites" class="btn" id="btnAsk">찜한 여행지</a>
    </nav>
    <nav class="nav-actions">
        <a href="/login" class="btn ghost">로그인</a>
        <a href="/signup" class="btn">회원가입</a>
    </nav>
    <div style="padding: 10px;">
        <span th:text="${username} + '님, 환영합니다!'"></span>
    </div>
</header>
<div id="pageLoadingOverlay" class="page-loading-overlay hidden" role="status" aria-live="polite" aria-label="데이터 로드 중">
    <div class="page-loading-card" id="pageLoadingCard">
        <div class="page-loading-spinner" aria-hidden="true"></div>
        <div class="page-loading-text">AI가 여행지를 추천하는 중입니다…</div>
    </div>
</div>
<section class="hero" id="heroSection" aria-hidden="false">
    <div>
        <h1>당신만의 완벽한 여행지를<br/>찾아보세요</h1>
        <p>AI가 추천하는 맞춤형 여행지로 특별한 여행을 계획해보세요</p>
    </div>
    <div class="scroll-hint" aria-hidden="true">
        <div class="chev"></div>
        <div>아래로 스크롤하여 시작</div>
    </div>
</section>
<main>
    <div class="container">
        <h1>TripPick AI</h1>

        <form class="search-card" action="/askAI" method="post">
            <input type="hidden" th:if="${_csrf != null}" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
            <input type="text" name="area" placeholder="어느 지역으로 가시나요?" required>
            <input type="text" name="mood" placeholder="어떤 분위기를 원하세요?" required>
            <button type="submit">AI에게 물어보기</button>
        </form>

        <div>
            <h3>지역명:</h3>
            <p th:text="${area}"></p>
        </div>

        <section th:if="${placeInfos != null and !#lists.isEmpty(placeInfos)}" class="grid" id="placesGrid">
            <div th:each="placeInfo : ${placeInfos}"
                 class="place-card"
                 th:attr="data-name=${placeInfo.name},
                  data-intro=${placeInfo.introduction},
                  data-visit-tip=${placeInfo.visitTip},
                  data-image=${placeInfo.imageUrl}">
                <div class="card-thumb">
                    <img th:src="${placeInfo.imageUrl}" alt="장소 이미지" onerror="this.style.display='none'">
                </div>
                <div class="card-body">
                    <div class="place-name" th:text="${placeInfo.name}">장소 이름</div>
                    <div class="place-intro" th:text="${placeInfo.introduction}">소개</div>
                    <div class="keywords">
                        <span th:each="kw : ${placeInfo.keywords}" class="kw" th:text="${kw}">키워드</span>
                    </div>

                    <div class="visit-tip-hidden" style="display:none" th:text="${placeInfo.visitTip}"></div>
                    <ul class="goodpoints-hidden" style="display:none">
                        <li th:each="gp : ${placeInfo.goodPoints}" th:text="${gp}">좋은 점</li>
                    </ul>
                </div>
            </div>
        </section>

        <div th:unless="${placeInfos != null and !#lists.isEmpty(placeInfos)}">
            <p>정보가 없습니다.</p>
        </div>
    </div>
</main>


<div class="overlay" id="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div class="modal-header" id="modalHeader">

            <button id="favBtn" class="fav-btn" aria-pressed="false" aria-label="즐겨찾기" title="즐겨찾기">
                <svg id="favIcon" viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" focusable="false">
                    <path class="heart-path" d="M12 21s-7-4.634-9.064-7.01C0.879 10.78 3.06 6 7.5 6 9.59 6 12 8.06 12 8.06S14.41 6 16.5 6C20.94 6 23.121 10.78 21.064 13.99 19 16.366 12 21 12 21z"></path>
                </svg>
            </button>

            <button class="close-btn" id="closeBtn" aria-label="닫기">✕</button>
        </div>

        <div class="modal-body">
            <h2 id="modalTitle">장소 이름</h2>
            <div class="tag-area" id="modalKeywords"></div>
            <p id="modalIntro">소개</p>

            <div class="goodpoints">
                <strong>이런 점이 좋아요</strong>
                <ul id="modalGoodPoints"></ul>
            </div>

            <div class="visit-tip">
                <strong>방문 팁:</strong>
                <p id="modalVisitTip"></p>
            </div>
        </div>
    </div>
</div>

<script th:inline="javascript">
    // 로그인 관련 변수 (기존과 동일)
    var loggedInUsername = [[${#authentication != null && #authentication.principal != null && #authentication.principal.toString() != 'anonymousUser' ? #authentication.name : null}]];
    var userFavoriteNames = new Set(/*[[${favoriteNames}]]*/ []);
    var csrfToken = /*[[${_csrf != null ? _csrf.token : ''}]]*/ '';
    var csrfHeaderName = /*[[${_csrf != null ? _csrf.headerName : ''}]]*/ '';

    // ===========================================
    // ⭐⭐ 로딩바 관련 함수 정의 ⭐⭐
    // ===========================================
    const pageLoadingOverlay = document.getElementById('pageLoadingOverlay');
    let initialLoadTime = Date.now(); // 로딩 시작 시간 기록

    /**
     * 로딩 오버레이를 화면에 표시합니다.
     */
    function showPageLoading(text) {
        if (pageLoadingOverlay) {
            const tEl = pageLoadingOverlay.querySelector('.page-loading-text');
            if (tEl) tEl.textContent = text || '잠시만 기다려주세요...';

            // 로딩 오버레이를 표시하고, 시작 시간을 갱신합니다.
            pageLoadingOverlay.classList.remove('hidden');
            pageLoadingOverlay.setAttribute('aria-hidden', 'false');
            initialLoadTime = Date.now();
        }
    }

    /**
     * 로딩 오버레이를 숨깁니다.
     */
    function hidePageLoading() {
        if (pageLoadingOverlay) {
            const elapsed = Date.now() - initialLoadTime;
            const minDisplayTime = 100; // 최소 표시 시간 (순간 깜빡임 방지)
            const delay = Math.max(0, minDisplayTime - elapsed);

            setTimeout(() => {
                pageLoadingOverlay.classList.add('hidden'); // hidden 클래스 추가하여 숨김
                pageLoadingOverlay.setAttribute('aria-hidden', 'true');
            }, delay);
        }
    }

    /**
     * 그리드 내의 모든 이미지 로드가 완료될 때까지 기다렸다가 콜백을 실행합니다.
     */
    function waitForImagesInCardsThen(callback) {
        const grid = document.getElementById('placesGrid');
        if (!grid) {
            callback();
            return;
        }
        const imgs = Array.from(grid.querySelectorAll('img'));
        if (imgs.length === 0) {
            callback();
            return;
        }
        let remaining = imgs.length;
        const onOne = () => {
            remaining--;
            if (remaining <= 0) callback();
        };

        let loadedCount = 0;
        imgs.forEach(img => {
            if (img.complete) {
                loadedCount++;
            } else {
                img.addEventListener('load', onOne, { once: true });
                img.addEventListener('error', onOne, { once: true });
            }
        });

        // 이미 로드된 이미지가 있다면, 남은 이미지 개수 갱신 후 콜백 호출
        remaining -= loadedCount;
        if (remaining <= 0) {
            callback();
            return;
        }

        // 타임아웃 추가: 이미지 로드가 너무 길어지면 6초 후 강제 종료
        setTimeout(() => {
            if (remaining > 0) callback();
        }, 6000);
    }
    // ===========================================


    (function initScreenTransition(){ if (window.__tripPickScreenInit) return; // 중복 방지 window.__tripPickScreenInit = true;
        document.addEventListener('DOMContentLoaded', () => {
            const header = document.getElementById('appHeader'); const hero = document.getElementById('heroSection');
            const mainContent = document.getElementById('mainContent'); const btnHome = document.getElementById('btnHome');
            const btnAsk = document.getElementById('btnAsk');
            if (btnHome) {
                btnHome.addEventListener('click', () => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            }

            if (btnAsk && mainContent) {
                btnAsk.addEventListener('click', () => {
                    mainContent.scrollIntoView({ behavior: 'smooth' });
                });
            }

            if (mainContent && hero) {
                const io = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            hero.classList.add('hidden');
                        } else {
                            hero.classList.remove('hidden');
                        }
                    });
                }, { threshold: 0.06 });
                io.observe(mainContent);
                // 필요하면 전역 변수로 보관: window._tripPickIO = io;
            }

// 헤더 자동 숨김(스크롤 방향)
            let lastY = window.scrollY;
            let ticking = false;
            window.addEventListener('scroll', () => {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        const currentY = window.scrollY;
                        if (header) {
                            if (currentY > lastY && currentY > 80) {
                                header.classList.add('hidden');
                            } else {
                                header.classList.remove('hidden');
                            }
                        }
                        lastY = currentY;
                        ticking = false;
                    });
                    ticking = true;
                }
            });

// 작은 화면 초기 상태 처리
            if (window.innerHeight < 600 && hero) {
                hero.classList.add('hidden');
            }
        }); })();


    document.addEventListener('DOMContentLoaded', function () {
        const cards = document.querySelectorAll('.place-card');
        console.log('place-card count =', cards.length);
        const overlay = document.getElementById('overlay');
        const closeBtn = document.getElementById('closeBtn');
        const modalImage = document.getElementById('modalImage');
        const modalTitle = document.getElementById('modalTitle');
        const modalKeywords = document.getElementById('modalKeywords');
        const modalIntro = document.getElementById('modalIntro');
        const modalGoodPoints = document.getElementById('modalGoodPoints');
        const modalVisitTip = document.getElementById('modalVisitTip');
        const favBtn = document.getElementById('favBtn');

        // ⭐⭐ 1. 페이지 로드 완료 시: 로딩바 숨기기 (이미지 로드 대기) ⭐⭐
        waitForImagesInCardsThen(hidePageLoading);

        // ⭐⭐ 2. 폼 제출 시: 로딩바 표시 ⭐⭐
        const searchForm = document.querySelector('.search-card');
        if (searchForm) {
            searchForm.addEventListener('submit', function (event) {
                showPageLoading('AI가 여행지를 추천하는 중입니다...');
            });
        }


        function openModal(obj) {
            if (modalImage) {
                if (obj.imageUrl) {
                    modalImage.src = obj.imageUrl;
                    modalImage.style.display = 'block';
                } else {
                    modalImage.style.display = 'none';
                    modalImage.removeAttribute('src');
                }
            }

            if (modalTitle) modalTitle.textContent = obj.name || '';
            if (modalIntro) modalIntro.textContent = obj.introduction || '';

            if (modalKeywords) {
                modalKeywords.innerHTML = '';
                (obj.keywords || []).forEach(k => {
                    const s = document.createElement('span');
                    s.className = 'kw';
                    s.textContent = k;
                    modalKeywords.appendChild(s);
                });
            }

            if (modalGoodPoints) {
                modalGoodPoints.innerHTML = '';
                (obj.goodPoints || []).forEach(gp => {
                    const li = document.createElement('li');
                    li.textContent = gp;
                    modalGoodPoints.appendChild(li);
                });
            }

            if (modalVisitTip) modalVisitTip.textContent = obj.visitTip || obj.visit_tip || obj.visit || '';

            if (overlay) {
                overlay.classList.add('open');
                overlay.setAttribute('aria-hidden', 'false');
            }

            if (favBtn) {
                // 모달을 열 때, 이 장소가 "찜 목록(Set)"에 있는지 확인
                if (loggedInUsername && userFavoriteNames.has(obj.name)) {
                    // 이미 찜한 곳: 빨간 하트로 시작
                    favBtn.classList.add('active');
                    favBtn.setAttribute('aria-pressed', 'true');
                }else {
                    // 찜 안 한 곳: 회색 하트로 시작
                    favBtn.classList.remove('active');
                    favBtn.setAttribute('aria-pressed', 'false');
                }
                // 하트 버튼을 클릭하면 무슨 일을 할지
                favBtn.onclick = () => {
                    if (!loggedInUsername) {
                        alert('로그인이 필요합니다!');
                        window.location.href = '/login'; // 로그인 페이지로 이동
                        return;
                    }

                    // 로그인 했다면, 백엔드로 신호를 보낼 데이터
                    const favoriteData = {
                        placeName: obj.name,
                        placeIntroduction: obj.introduction,
                        placeImageUrl: obj.imageUrl
                    };

                    if(favBtn.classList.contains('active')){
                        fetch('/favorites/remove', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', [csrfHeaderName]: csrfToken},
                            body: JSON.stringify((favoriteData))
                        })
                            .then(response => response.json())
                            .then(data => {
                                if (data.status === 'success') {
                                    userFavoriteNames.delete(obj.name); // JS 목록에서 삭제
                                    favBtn.classList.remove('active');  // 하트 회색으로
                                    favBtn.setAttribute('aria-pressed', 'false');
                                }else {
                                    alert('찜 삭제에 실패했습니다: ' + data.message);
                                }
                            }) .catch(error => console.error('Error:', error));
                    }else {
                        // 백엔드의 /favorites/add으로 보내기
                        fetch('/favorites/add', {
                            method: 'POST',                                 //암호(CSRF 토큰)를 헤더에 실어 보냅
                            headers: { 'Content-Type': 'application/json', [csrfHeaderName]: csrfToken },
                            body: JSON.stringify(favoriteData) // 데이터를 JSON 문자열로 변환
                        })
                            .then(response => response.json())
                            .then(data => {
                                if (data.status === 'success') {
                                    // js 목록에도 이 장소를 추가해서, 모달을 껐다 켜도 하트가 유지되게 함
                                    userFavoriteNames.add(obj.name);
                                    favBtn.classList.add('active'); // 하트 빨간색으로
                                    favBtn.setAttribute('aria-pressed', 'true');
                                } else {
                                    alert('찜하기에 실패했습니다: ' + data.message);
                                }
                            })
                            .catch(error => {
                                console.error('Error:', error);
                                alert('찜하는 중 오류가 발생했습니다.');
                            });
                    }
                };
            }
        }

        function closeModal() {
            if (overlay) {
                overlay.classList.remove('open');
                overlay.setAttribute('aria-hidden', 'true');
            }
        }

        cards.forEach(card => {
            if (card._hasModalHandler) return;
            card._hasModalHandler = true;

            card.addEventListener('click', function () {
                const obj = {};
                obj.name = card.getAttribute('data-name') || card.querySelector('.place-name')?.textContent?.trim() || '';
                obj.introduction = card.getAttribute('data-intro') || card.querySelector('.place-intro')?.textContent?.trim() || '';
                obj.imageUrl = card.getAttribute('data-image') || card.querySelector('.card-thumb img')?.src || '';
                const kwEls = card.querySelectorAll('.kw');
                obj.keywords = Array.from(kwEls).map(n => n.textContent.trim());

                const rawGood = card.getAttribute('data-goodpoints');
                if (rawGood) {
                    try {
                        obj.goodPoints = JSON.parse(rawGood);
                    } catch (e) {
                        obj.goodPoints = rawGood.split(',').map(s => s.trim()).filter(Boolean);
                    }
                } else {
                    const gpEls = card.querySelectorAll('.goodpoints-hidden li');
                    obj.goodPoints = Array.from(gpEls).map(n => n.textContent.trim());
                }

                const rawTip = card.getAttribute('data-visit-tip');
                if (rawTip) {
                    obj.visitTip = rawTip;
                } else {
                    obj.visitTip = card.querySelector('.visit-tip-hidden')?.textContent?.trim() || '';
                }

                console.log('modal obj =', obj);
                openModal(obj);
            });
        });

        if (closeBtn) closeBtn.addEventListener('click', closeModal);
        if (overlay) {
            overlay.addEventListener('click', function (e) {
                if (e.target === overlay) closeModal();
            });
        }
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && overlay && overlay.classList.contains('open')) closeModal();
        });
    });
</script>
</body>
</html>